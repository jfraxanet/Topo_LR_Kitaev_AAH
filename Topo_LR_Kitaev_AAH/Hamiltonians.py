# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/01_Hamiltonians.ipynb (unless otherwise specified).

__all__ = ['H_OBC_Kitaev_LR_QP', 'H_OBC_Majoranas_Kitaev_LR_QP', 'H_APBC_Kitaev_LR_QP', 'H_Kitaev_LR_QP',
           'H_Kitaev_LR_QP_inf', 'd_k_H_Kitaev_LR_QP_inf', 'd_phase_H_Kitaev_LR_QP_inf', 'h_chiral_Kitaev_LR_QP',
           'h_chiral_Kitaev_LR_QP_inf', 'H_pbc_sp', 'd_h_chiral_Kitaev_LR_QP_inf', 'd_H_pbc_sp', 'HLP_d', 'Fibonacci',
           'rot_sigma_y', 'f', 'df', 'HLP']

# Cell

import numpy as np
from mpmath import *

# Cell

def H_OBC_Kitaev_LR_QP(params, mu, length, rot = False, AA = False):

    '''Compute the real space Hamiltonian with OBC for the Kitaev chain
    with any value of alpha, Fn1/Fn and finite length'''

    alpha = params['alpha']
    t, delta = params['t'], params['delta']
    Fn1, Fn = params['Fn1'], params['Fn']
    phase, constant = params['phase'], params['constant']

    sx = np.array([[0, 1],[ 1, 0]])
    sy = np.array([[0, -1j],[1j, 0]])
    sz = np.array([[1, 0],[0, -1]])

    H_local = np.zeros((2*Fn*length, 2*Fn*length), dtype='complex')
    B = t/2 * sz - delta * 1j * sy
    for x in range(Fn*length):
        for y in np.arange(x, Fn*length):
            if x == y:
                if constant == True:
                    A_k = -mu * sz
                else:
                    if AA == False:
                        A_k = -mu * sz * (1-np.cos(2*np.pi*Fn1/Fn*x+phase))
                    else:
                        A_k = -mu * sz * (np.cos(2*np.pi*Fn1/Fn*x+phase))
                for j in [0,1]:
                    for l in [0,1]:
                        H_local[2*x+l][2*y+j] = A_k[l][j]
            elif y == x + 1:
                for j in [0,1]:
                    for l in [0,1]:
                        H_local[2*x+l][2*y+j] = B[l][j]
                        H_local[2*y+l][2*x+j] = np.conjugate(B.T[l][j])
            else:
                d = abs(y-x)
                C = - delta/d**alpha * 1j * sy
                for j in [0,1]:
                    for l in [0,1]:
                        H_local[2*x+l][2*y+j] = C[l][j]
                        H_local[2*y+l][2*x+j] = np.conjugate(C.T[l][j])

    if rot == True:
        R = rot_sigma_y([0,1,0], np.pi/2, length*Fn)
        H_local = R@H_local@np.conjugate(R.T)

    return H_local


def H_OBC_Majoranas_Kitaev_LR_QP(params, mu, length, rot = False, AA = False):

    '''Compute the real space Hamiltonian with OBC for the Kitaev chain
    with any value of alpha, Fn1/Fn and finite length. Here we use the Majorana basis.'''

    mu = mu*2
    alpha = params['alpha']
    t, delta = params['t']*2, params['delta']*4
    Fn1, Fn = params['Fn1'], params['Fn']
    phase, constant = params['phase'], params['constant']

    sx = np.array([[0, 1],[ 1, 0]])
    sy = np.array([[0, -1j],[1j, 0]])
    sz = np.array([[1, 0],[0, -1]])

    H_local = np.zeros((2*Fn*length, 2*Fn*length), dtype='complex')
    B = t/4 * sy - delta/4 * 1j * sx
    for x in range(Fn*length):
        for y in np.arange(x, Fn*length):
            if x == y:
                if constant == True:
                    A_k = -mu/2 * sy
                else:
                    if AA == False:
                        A_k = -mu/2 * sx * 1j * (1-np.cos(2*np.pi*Fn1/Fn*x+phase))
                    else:
                        A_k = -mu/2 * sy * (np.cos(2*np.pi*Fn1/Fn*x+phase))
                for j in [0,1]:
                    for l in [0,1]:
                        H_local[2*x+l][2*y+j] = A_k[l][j]
            elif y == x + 1:
                for j in [0,1]:
                    for l in [0,1]:
                        H_local[2*x+l][2*y+j] = B[l][j]
                        H_local[2*y+l][2*x+j] = np.conjugate(B.T[l][j])
            else:
                d = abs(y-x)
                C = - delta/4/d**alpha * 1j * sx
                for j in [0,1]:
                    for l in [0,1]:
                        H_local[2*x+l][2*y+j] = C[l][j]
                        H_local[2*y+l][2*x+j] = np.conjugate(C.T[l][j])

    if rot == True:
        R = rot_sigma_y([0,1,0], np.pi/2, length*Fn)
        H_local = R@H_local@np.conjugate(R.T)

    return H_local

# Cell

def H_APBC_Kitaev_LR_QP(params, mu, length, rot=False, AA=False):

    '''Compute the real space Hamiltonian with APBC for the Kitaev chain
    with any value of alpha, Fn1/Fn and finite length'''

    alpha = params['alpha']
    t, delta = params['t'], params['delta']
    Fn1, Fn = params['Fn1'], params['Fn']
    phase, constant = params['phase'], params['constant']

    sy = np.array([[0, -1j],[1j, 0]])
    sx = np.array([[0, 1],[ 1, 0]])
    sz = np.array([[1, 0],[0, -1]])

    H = np.zeros((2*length*Fn, 2*length*Fn), dtype='complex')
    B = t/2 * sz - delta * 1j * sy
    for x in range(Fn*length):
        for y in np.arange(x, Fn*length):
            if x == y:
                if constant == True:
                    A_k = -mu * sz
                else:
                    if AA == False:
                        A_k = -mu * sz * (1-np.cos(2*np.pi*Fn1/Fn*x+phase))
                    else:
                        A_k = -mu * sz * (np.cos(2*np.pi*Fn1/Fn*x+phase))
                for j in [0,1]:
                    for l in [0,1]:
                        H[2*x+l][2*y+j] = A_k[l][j]
            elif y == x + 1:
                for j in [0,1]:
                    for l in [0,1]:
                        H[2*x+l][2*y+j] = B[l][j]
                        H[2*y+l][2*x+j] = np.conjugate(B.T[l][j])
            else:
                d = min(y-x, length*Fn-(y-x))
                C = - delta/d**alpha * 1j * sy
                for j in [0,1]:
                    for l in [0,1]:
                        H[2*x+l][2*y+j] = C[l][j]
                        H[2*y+l][2*x+j] = np.conjugate(C.T[l][j])

    B = t/2 * sz
    for j in [0,1]:
        for l in [0,1]:
            H[2*(Fn*length-1)+l][j] += -B[l][j]
            H[l][2*(Fn*length-1)+j] += np.conjugate(-B.T[l][j])

    if rot == True:
        R = rot_sigma_y([0,1,0], np.pi/2, Fn*length)
        H = R@H@np.conjugate(R.T)

    return H

# Cell

def H_Kitaev_LR_QP(params, k, mu, length, rot=True, AA = False):

    '''Compute the momentum Hamiltonian with APBC for the Kitaev chain
    with any value of alpha, Fn1/Fn and finite length'''

    alpha = params['alpha']
    t, delta = params['t'], params['delta']
    Fn1, Fn = params['Fn1'], params['Fn']
    phase, constant = params['phase'], params['constant']

    sx = np.array([[0, 1],[ 1, 0]])
    sy = np.array([[0, -1j],[1j, 0]])
    sz = np.array([[1, 0],[0, -1]])

    H_local = np.zeros((2*Fn, 2*Fn), dtype='complex')
    B = t/2 * sz - delta * 1j * sy
    for x in range(Fn):
        for y in np.arange(x, Fn):
            if x == y:
                if constant == True:
                    A_k = -mu * sz
                else:
                    if AA == False:
                        A_k = -mu * sz * (1-np.cos(2*np.pi*Fn1/Fn*x+phase))
                    else:
                        A_k = -mu * sz * (np.cos(2*np.pi*Fn1/Fn*x+phase))
                for j in [0,1]:
                    for l in [0,1]:
                        H_local[2*x+l][2*y+j] = A_k[l][j]
            elif y == x + 1:
                for j in [0,1]:
                    for l in [0,1]:
                        H_local[2*x+l][2*y+j] = B[l][j]
                        H_local[2*y+l][2*x+j] = np.conjugate(B.T[l][j])
            else:
                d = min(abs(y-x), length*Fn-abs(y-x))
                C = - delta/d**alpha * 1j * sy
                for j in [0,1]:
                    for l in [0,1]:
                        H_local[2*x+l][2*y+j] = C[l][j]
                        H_local[2*y+l][2*x+j] = np.conjugate(C.T[l][j])

    H_pbc_t = np.zeros((2*Fn, 2*Fn), dtype='complex')
    B = t/2 * sz
    for j in [0,1]:
        for l in [0,1]:
            H_pbc_t[2*(Fn-1)+l][j] = B[l][j]*np.exp(1j*k)
            H_pbc_t[l][2*(Fn-1)+j] = np.conjugate(B.T[l][j])*np.exp(-1j*k)


    def block_matrix(Fn, k, delta, alpha, x, y, length):

        ''' Return block matrix C corresponding to the sum of H_l at position x, y'''

        C = np.zeros((2, 2), dtype='complex')
        sy = np.array([[0, -1j],[1j, 0]])
        for l in range(1,length):
            d = min(l, length-l)
            d1 = min(Fn*l-(x-y), length*Fn-(Fn*l-(x-y)))
            d2 = min(Fn*l-(y-x), length*Fn-(Fn*l-(y-x)))
            C += - delta/2*1j*sy*(np.exp(1j*k*l)/d1**alpha - np.exp(-1j*k*l)/d2**alpha)

        return C


    H_pbc_delta = np.zeros((2*Fn, 2*Fn), dtype='complex')
    for x in range(Fn):
        for y in range(Fn):
            C = block_matrix(Fn, k, delta, alpha, x, y, length)
            for j in [0,1]:
                for l in [0,1]:
                     H_pbc_delta[2*x+l][2*y+j] = C[l][j]

    H_k = H_local + H_pbc_t + H_pbc_delta

    if rot == True:
        R = rot_sigma_y([0,1,0], np.pi/2, Fn)
        H_k = R@H_k@np.conjugate(R.T)

    return H_k

# Cell

def H_Kitaev_LR_QP_inf(params, k, mu, rot=False, AA=True):

    '''Compute the momentum Hamiltonian with APBC for the Kitaev chain
    with any value of alpha and Fn1/Fn. The system is infinite.'''

    alpha = params['alpha']
    t, delta = params['t'], params['delta']
    Fn1, Fn = params['Fn1'], params['Fn']
    phase, constant = params['phase'], params['constant']

    sx = np.array([[0, 1],[ 1, 0]])
    sy = np.array([[0, -1j],[1j, 0]])
    sz = np.array([[1, 0],[0, -1]])

    H_local = np.zeros((2*Fn, 2*Fn), dtype='complex')
    B = t/2 * sz - delta * 1j * sy
    for x in range(Fn):
        for y in np.arange(x, Fn):
            if x == y:
                if constant == True:
                    A_k = -mu * sz
                else:
                    if AA == False:
                        A_k = -mu * sz * (1-np.cos(2*np.pi*Fn1/Fn*x+phase))
                    else:
                        A_k = -mu * sz * (np.cos(2*np.pi*Fn1/Fn*x+phase))
                for j in [0,1]:
                    for l in [0,1]:
                        H_local[2*x+l][2*y+j] = A_k[l][j]
            elif y == x + 1:
                for j in [0,1]:
                    for l in [0,1]:
                        H_local[2*x+l][2*y+j] = B[l][j]
                        H_local[2*y+l][2*x+j] = np.conjugate(B.T[l][j])
            else:
                d = y-x
                C = - delta/d**alpha * 1j * sy
                for j in [0,1]:
                    for l in [0,1]:
                        H_local[2*x+l][2*y+j] = C[l][j]
                        H_local[2*y+l][2*x+j] = np.conjugate(C.T[l][j])

    H_pbc_t = np.zeros((2*Fn, 2*Fn), dtype='complex')
    B = t/2 * sz
    for j in [0,1]:
        for l in [0,1]:
            H_pbc_t[2*(Fn-1)+l][j] = B[l][j]*np.exp(1j*k)
            H_pbc_t[l][2*(Fn-1)+j] = np.conjugate(B.T[l][j])*np.exp(-1j*k)

    H_pbc_delta = np.zeros((2*Fn, 2*Fn), dtype='complex')
    for x in range(Fn):
        for y in range(Fn):
            C = - delta * 1j * sy * np.exp(1j*k)/Fn**alpha*HLP(k, alpha, Fn, x, y)
            for j in [0,1]:
                for l in [0,1]:
                     H_pbc_delta[2*x+l][2*y+j] = C[l][j]

    H_k = H_local + H_pbc_t + H_pbc_delta + np.conjugate(H_pbc_delta.T)

    if rot == True:
        R = rot_sigma_y([0,1,0], np.pi/2, Fn)
        H_k = R@H_k@np.conjugate(R.T)

    return H_k


def d_k_H_Kitaev_LR_QP_inf(params, k, mu, rot=False, AA=True):

    ''' Analytical derivative of the Hamiltonian for k in momentum space for an infinite system. '''

    alpha = params['alpha']
    t, delta = params['t'], params['delta']
    Fn1, Fn = params['Fn1'], params['Fn']
    phase, constant = params['phase'], params['constant']

    sx = np.array([[0, 1],[ 1, 0]])
    sy = np.array([[0, -1j],[1j, 0]])
    sz = np.array([[1, 0],[0, -1]])

    d_H_pbc_t = np.zeros((2*Fn, 2*Fn), dtype='complex')
    B = t/2 * sz
    for j in [0,1]:
        for l in [0,1]:
            d_H_pbc_t[2*(Fn-1)+l][j] = 1j * B[l][j]*np.exp(1j*k)
            d_H_pbc_t[l][2*(Fn-1)+j] = -1j * np.conjugate(B.T[l][j])*np.exp(-1j*k)

    d_H_pbc_delta = np.zeros((2*Fn, 2*Fn), dtype='complex')
    for x in range(Fn):
        for y in range(Fn):
            C = - delta * 1j * sy * 1j * np.exp(1j*k)/Fn**(alpha+1) * (Fn*HLP(k, alpha-1, Fn, x, y)+(x-y)* HLP(k, alpha, Fn, x, y))
            for j in [0,1]:
                for l in [0,1]:
                     d_H_pbc_delta[2*x+l][2*y+j] = C[l][j]

    d_H_k = d_H_pbc_t + d_H_pbc_delta + np.conjugate(d_H_pbc_delta.T)

    if rot == True:
        R = rot_sigma_y(np.array([0,1,0]), np.pi/2, Fn)
        d_H_k = R@d_H_k@np.conjugate(R.T)

    return d_H_k


def d_phase_H_Kitaev_LR_QP_inf(params, k, mu, rot=False, AA=True):

    ''' Analytical derivative of the Hamiltonian for phi in momentum space for an infinite system. '''

    alpha = params['alpha']
    t, delta = params['t'], params['delta']
    Fn1, Fn = params['Fn1'], params['Fn']
    phase, constant = params['phase'], params['constant']

    sx = np.array([[0, 1],[ 1, 0]])
    sy = np.array([[0, -1j],[1j, 0]])
    sz = np.array([[1, 0],[0, -1]])

    d_H_local = np.zeros((2*Fn, 2*Fn), dtype='complex')
    for x in range(Fn):
        for y in np.arange(x, Fn):
            if x == y:
                if constant == True:
                    A_k = 0
                else:
                    if AA == False:
                        A_k = -mu * sz * (np.sin(2*np.pi*Fn1/Fn*x+phase))
                    else:
                        A_k = mu * sz * (np.sin(2*np.pi*Fn1/Fn*x+phase))
                for j in [0,1]:
                    for l in [0,1]:
                        d_H_local[2*x+l][2*y+j] = A_k[l][j]

    d_H_k = d_H_local

    if rot == True:
        R = rot_sigma_y(np.array([0,1,0]), np.pi/2, Fn)
        d_H_k = R@d_H_k@np.conjugate(R.T)

    return d_H_k

# Cell

def h_chiral_Kitaev_LR_QP(params, k, mu, length, AA=False):

    '''Computes one block of the off-diagonal Hamiltonian in momentum space for a finite system with APBC'''

    alpha = params['alpha']
    t, delta = params['t'], params['delta']
    Fn1, Fn = params['Fn1'], params['Fn']
    phase, constant = params['phase'], params['constant']

    H_local = np.zeros((Fn, Fn), dtype='complex')
    for x in range(Fn):
        for y in np.arange(x, Fn):
            if x == y:
                if constant == True:
                    H_local[x][y] = -mu
                else:
                    if AA == False:
                        H_local[x][y] = -mu * (1-np.cos(2*np.pi*Fn1/Fn*x+phase))
                    else:
                        H_local[x][y] = -mu * (np.cos(2*np.pi*Fn1/Fn*x+phase))
            elif y == x + 1:
                    H_local[x][y] = -delta + t/2
                    H_local[y][x] = + delta + t/2
            else:
                d = min(abs(y-x), length*Fn-abs(y-x))
                H_local[x][y] = -delta/d**alpha
                H_local[y][x] = + delta/d**alpha

    H_pbc_t = np.zeros((Fn, Fn), dtype='complex')
    H_pbc_t[Fn-1][0] = t/2*np.exp(1j*k)
    H_pbc_t[0][Fn-1] = t/2*np.exp(-1j*k)

    H_pbc_delta = np.zeros((Fn, Fn), dtype='complex')
    for x in range(Fn):
        for y in range(Fn):
            c = 0
            for l in range(1,length):
                d1 = min(Fn*l-(x-y), length*Fn-(Fn*l-(x-y)))
                d2 = min(Fn*l-(y-x), length*Fn-(Fn*l-(y-x)))
                c += - delta/2*(np.exp(1j*k*l)/d1**alpha - np.exp(-1j*k*l)/d2**alpha)
            H_pbc_delta[x][y] = c

    Hc = H_local + H_pbc_t + H_pbc_delta

    return Hc

# Cell

def h_chiral_Kitaev_LR_QP_inf(params, k, mu, AA, H_pbc_delta):

    '''Computes one block of the off-diagonal Hamiltonian in momentum space for an infinite system'''

    alpha = params['alpha']
    t, delta = params['t'], params['delta']
    Fn1, Fn = params['Fn1'], params['Fn']
    phase, constant = params['phase'], params['constant']

    H_local = np.zeros((Fn, Fn), dtype='complex')
    for x in range(Fn):
        for y in np.arange(x, Fn):
            if x == y:
                if constant == True:
                    H_local[x][y] = -mu
                else:
                    if AA == False:
                        H_local[x][y] = -mu * (1-np.cos(2*np.pi*Fn1/Fn*x+phase))
                    else:
                        H_local[x][y] = -mu * (np.cos(2*np.pi*Fn1/Fn*x+phase))
            elif y == x + 1:
                    H_local[x][y] = -delta + t/2
                    H_local[y][x] = + delta + t/2
            else:
                d = (y-x)
                H_local[x][y] = -delta/d**alpha
                H_local[y][x] = + delta/d**alpha

    H_pbc_t = np.zeros((Fn, Fn), dtype='complex')
    H_pbc_t[Fn-1][0] = t/2*np.exp(1j*k)
    H_pbc_t[0][Fn-1] = t/2*np.exp(-1j*k)

    Hc = H_local + H_pbc_t + H_pbc_delta - np.conjugate(H_pbc_delta.T)

    return Hc

def H_pbc_sp(params, k):

    '''Computes the analytical expression of the long-range infinite part of
    the off-diagonal Hamiltonian. Does not depend on the chemical potential.'''

    alpha = params['alpha']
    delta = params['delta']
    Fn1, Fn = params['Fn1'], params['Fn']

    H_pbc_delta = np.zeros((Fn, Fn), dtype='complex')
    for dist in np.arange(-(Fn-1), Fn):
        c = - delta * np.exp(1j*k)/Fn**alpha * HLP_d(k, alpha, Fn, dist)
        for x in range(Fn):
            for y in range(Fn):
                if dist == (y-x):
                    H_pbc_delta[x][y] = c

    return H_pbc_delta

def d_h_chiral_Kitaev_LR_QP_inf(params, k, mu, AA, d_H_pbc_delta):

    '''Computes the analytical derivative of k of one block of the off-diagonal Hamiltonian
    in momentum space for an infinite system'''

    alpha = params['alpha']
    t, delta = params['t'], params['delta']
    Fn1, Fn = params['Fn1'], params['Fn']
    phase, constant = params['phase'], params['constant']

    d_H_pbc_t = np.zeros((Fn, Fn), dtype='complex')
    d_H_pbc_t[Fn-1][0] = 1j*t/2*np.exp(1j*k)
    d_H_pbc_t[0][Fn-1] = -1j*t/2*np.exp(-1j*k)

    Hc = d_H_pbc_t + d_H_pbc_delta - np.conjugate(d_H_pbc_delta.T)

    return Hc

def d_H_pbc_sp(params, k):

    '''Computes the analytical derivative of the long-range infinite part of
    the off-diagonal Hamiltonian. Does not depend on the chemical potential.'''

    alpha = params['alpha']
    delta = params['delta']
    Fn1, Fn = params['Fn1'], params['Fn']

    d_H_pbc_delta = np.zeros((Fn, Fn), dtype='complex')
    for dist in np.arange(-(Fn-1), Fn):
        c = - delta * 1j * np.exp(1j*k)/Fn**(alpha+1) * (Fn*HLP_d(k, alpha-1, Fn, dist)- dist * HLP_d(k, alpha, Fn, dist))
        for x in range(Fn):
            for y in range(Fn):
                if dist == (y-x):
                    d_H_pbc_delta[x][y] = c

    return d_H_pbc_delta

def HLP_d(k, alpha, Fn, dist):

    '''Closed form of sum of exponents using HLP function. dist is y-x'''

    f = lerchphi(np.exp(1j*k),alpha,(Fn+(dist))/Fn)
    return np.float(re(f))+ 1j*np.float(im(f))

# Cell

def Fibonacci(iterations):

    """Return Fibonacci sequence number depending on the iterations"""

    Fn1 = 0
    Fn = 1
    for n in range(iterations):
        Fn2 = Fn1
        Fn1 = Fn
        Fn = Fn1 + Fn2

    return Fn1, Fn


def rot_sigma_y(pvec, psi, Fn):

    '''Rotation around sigma y of an angle psi'''

    a = np.array([[np.cos(psi/2)-1j*pvec[2]*np.sin(psi/2), (-1j*pvec[0]-pvec[1])*np.sin(psi/2)],
                  [(-1j*pvec[0]+pvec[1])*np.sin(psi/2), np.cos(psi/2)+1j*pvec[2]*np.sin(psi/2)]])
    b = np.identity(Fn)

    return np.kron(b,a)


def f(k, alpha):

    '''Function f(k,alpha) in terms of the polylog functions'''

    f = -1j/2*(polylog(alpha,np.exp(1j*k))-polylog(alpha, np.exp(-1j*k)))
    return float(f.real) + 1j*float(f.imag)


def df(k, alpha):

    '''Derivative of function f(k,alpha) in terms of the polylog functions'''

    f = 1/2*(polylog(alpha-1,np.exp(1j*k))+polylog(alpha-1, np.exp(-1j*k)))
    return float(f.real) + 1j*float(f.imag)


def HLP(k, alpha, Fn, x, y):

    '''Closed form of sum of exponens using HLP function'''

    f = lerchphi(np.exp(1j*k),alpha,(Fn+(y-x))/Fn)
    return np.float(re(f))+ 1j*np.float(im(f))