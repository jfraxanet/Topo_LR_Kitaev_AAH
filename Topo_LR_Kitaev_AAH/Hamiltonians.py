# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/01_Hamiltonians.ipynb (unless otherwise specified).

__all__ = ['H_OBC_Kitaev_LR_QP', 'H_OBC_Majoranas_Kitaev_LR_QP', 'H_APBC_Kitaev_LR_QP', 'H_Kitaev_LR_QP',
           'H_Kitaev_LR_QP_inf', 'd_k_H_Kitaev_LR_QP_inf', 'd_phase_H_Kitaev_LR_QP_inf', 'h_chiral_Kitaev_LR_QP',
           'h_chiral_Kitaev_LR_QP_inf', 'H_pbc_sp', 'd_h_chiral_Kitaev_LR_QP_inf', 'd_H_pbc_sp', 'HLP_d',
           'H_OBC_Kitaev_twoband', 'H_APBC_Kitaev_twoband', 'H_Kitaev_twoband', 'H_Kitaev_twoband_inf',
           'analytic_Kitaev_twoband', 'h_Kitaev_twoband', 'd_h_Kitaev_twoband', 'h_Kitaev_twoband_inf',
           'd_h_Kitaev_twoband_inf', 'H_OBC_Kitaev_SR_QP', 'H_OBC_Majoranas_Kitaev_SR_QP', 'H_Kitaev_SR_QP',
           'Fibonacci', 'rot_sigma_y', 'f', 'df', 'HLP', 'sparse_diag']

# Cell

import numpy as np
from mpmath import *

# Cell

def H_OBC_Kitaev_LR_QP(params, mu, length, rot = False, AA = False):

    '''Compute the real space Hamiltonian with OBC for the Kitaev chain
    with any value of alpha, Fn1/Fn and finite length'''

    alpha = params['alpha']
    t, delta = params['t'], params['delta']
    Fn1, Fn = params['Fn1'], params['Fn']
    phase, constant = params['phase'], params['constant']

    sx = np.array([[0, 1],[ 1, 0]])
    sy = np.array([[0, -1j],[1j, 0]])
    sz = np.array([[1, 0],[0, -1]])

    H_local = np.zeros((2*Fn*length, 2*Fn*length), dtype='complex')
    B = t/2 * sz - delta * 1j * sy
    for x in range(Fn*length):
        for y in np.arange(x, Fn*length):
            if x == y:
                if constant == True:
                    A_k = -mu * sz
                else:
                    if AA == False:
                        A_k = -mu * sz * (1-np.cos(2*np.pi*Fn1/Fn*x+phase))
                    else:
                        A_k = -mu * sz * (np.cos(2*np.pi*Fn1/Fn*x+phase))
                for j in [0,1]:
                    for l in [0,1]:
                        H_local[2*x+l][2*y+j] = A_k[l][j]
            elif y == x + 1:
                for j in [0,1]:
                    for l in [0,1]:
                        H_local[2*x+l][2*y+j] = B[l][j]
                        H_local[2*y+l][2*x+j] = np.conjugate(B.T[l][j])
            else:
                d = abs(y-x)
                C = - delta/d**alpha * 1j * sy
                for j in [0,1]:
                    for l in [0,1]:
                        H_local[2*x+l][2*y+j] = C[l][j]
                        H_local[2*y+l][2*x+j] = np.conjugate(C.T[l][j])

    if rot == True:
        R = rot_sigma_y([0,1,0], np.pi/2, length*Fn)
        H_local = R@H_local@np.conjugate(R.T)

    return H_local


def H_OBC_Majoranas_Kitaev_LR_QP(params, mu, length, rot = False, AA = False):

    '''Compute the real space Hamiltonian with OBC for the Kitaev chain
    with any value of alpha, Fn1/Fn and finite length. Here we use the Majorana basis.'''

    mu = mu*2
    alpha = params['alpha']
    t, delta = params['t']*2, params['delta']*4
    Fn1, Fn = params['Fn1'], params['Fn']
    phase, constant = params['phase'], params['constant']

    sx = np.array([[0, 1],[ 1, 0]])
    sy = np.array([[0, -1j],[1j, 0]])
    sz = np.array([[1, 0],[0, -1]])

    H_local = np.zeros((2*Fn*length, 2*Fn*length), dtype='complex')
    B = t/4 * sy - delta/4 * 1j * sx
    for x in range(Fn*length):
        for y in np.arange(x, Fn*length):
            if x == y:
                if constant == True:
                    A_k = -mu/2 * sy
                else:
                    if AA == False:
                        A_k = -mu/2 * sx * 1j * (1-np.cos(2*np.pi*Fn1/Fn*x+phase))
                    else:
                        A_k = -mu/2 * sy * (np.cos(2*np.pi*Fn1/Fn*x+phase))
                for j in [0,1]:
                    for l in [0,1]:
                        H_local[2*x+l][2*y+j] = A_k[l][j]
            elif y == x + 1:
                for j in [0,1]:
                    for l in [0,1]:
                        H_local[2*x+l][2*y+j] = B[l][j]
                        H_local[2*y+l][2*x+j] = np.conjugate(B.T[l][j])
            else:
                d = abs(y-x)
                C = - delta/4/d**alpha * 1j * sx
                for j in [0,1]:
                    for l in [0,1]:
                        H_local[2*x+l][2*y+j] = C[l][j]
                        H_local[2*y+l][2*x+j] = np.conjugate(C.T[l][j])

    if rot == True:
        R = rot_sigma_y([0,1,0], np.pi/2, length*Fn)
        H_local = R@H_local@np.conjugate(R.T)

    return H_local

# Cell

def H_APBC_Kitaev_LR_QP(params, mu, length, rot=False, AA=False):

    '''Compute the real space Hamiltonian with APBC for the Kitaev chain
    with any value of alpha, Fn1/Fn and finite length'''

    alpha = params['alpha']
    t, delta = params['t'], params['delta']
    Fn1, Fn = params['Fn1'], params['Fn']
    phase, constant = params['phase'], params['constant']

    sy = np.array([[0, -1j],[1j, 0]])
    sx = np.array([[0, 1],[ 1, 0]])
    sz = np.array([[1, 0],[0, -1]])

    H = np.zeros((2*length*Fn, 2*length*Fn), dtype='complex')
    B = t/2 * sz - delta * 1j * sy
    for x in range(Fn*length):
        for y in np.arange(x, Fn*length):
            if x == y:
                if constant == True:
                    A_k = -mu * sz
                else:
                    if AA == False:
                        A_k = -mu * sz * (1-np.cos(2*np.pi*Fn1/Fn*x+phase))
                    else:
                        A_k = -mu * sz * (np.cos(2*np.pi*Fn1/Fn*x+phase))
                for j in [0,1]:
                    for l in [0,1]:
                        H[2*x+l][2*y+j] = A_k[l][j]
            elif y == x + 1:
                for j in [0,1]:
                    for l in [0,1]:
                        H[2*x+l][2*y+j] = B[l][j]
                        H[2*y+l][2*x+j] = np.conjugate(B.T[l][j])
            else:
                d = min(y-x, length*Fn-(y-x))
                C = - delta/d**alpha * 1j * sy
                for j in [0,1]:
                    for l in [0,1]:
                        H[2*x+l][2*y+j] = C[l][j]
                        H[2*y+l][2*x+j] = np.conjugate(C.T[l][j])

    B = t/2 * sz
    for j in [0,1]:
        for l in [0,1]:
            H[2*(Fn*length-1)+l][j] += -B[l][j]
            H[l][2*(Fn*length-1)+j] += np.conjugate(-B.T[l][j])

    if rot == True:
        R = rot_sigma_y([0,1,0], np.pi/2, Fn*length)
        H = R@H@np.conjugate(R.T)

    return H

# Cell

def H_Kitaev_LR_QP(params, k, mu, length, rot=True, AA = False):

    '''Compute the momentum Hamiltonian with APBC for the Kitaev chain
    with any value of alpha, Fn1/Fn and finite length'''

    alpha = params['alpha']
    t, delta = params['t'], params['delta']
    Fn1, Fn = params['Fn1'], params['Fn']
    phase, constant = params['phase'], params['constant']

    sx = np.array([[0, 1],[ 1, 0]])
    sy = np.array([[0, -1j],[1j, 0]])
    sz = np.array([[1, 0],[0, -1]])

    H_local = np.zeros((2*Fn, 2*Fn), dtype='complex')
    B = t/2 * sz - delta * 1j * sy
    for x in range(Fn):
        for y in np.arange(x, Fn):
            if x == y:
                if constant == True:
                    A_k = -mu * sz
                else:
                    if AA == False:
                        A_k = -mu * sz * (1-np.cos(2*np.pi*Fn1/Fn*x+phase))
                    else:
                        A_k = -mu * sz * (np.cos(2*np.pi*Fn1/Fn*x+phase))
                for j in [0,1]:
                    for l in [0,1]:
                        H_local[2*x+l][2*y+j] = A_k[l][j]
            elif y == x + 1:
                for j in [0,1]:
                    for l in [0,1]:
                        H_local[2*x+l][2*y+j] = B[l][j]
                        H_local[2*y+l][2*x+j] = np.conjugate(B.T[l][j])
            else:
                d = min(abs(y-x), length*Fn-abs(y-x))
                C = - delta/d**alpha * 1j * sy
                for j in [0,1]:
                    for l in [0,1]:
                        H_local[2*x+l][2*y+j] = C[l][j]
                        H_local[2*y+l][2*x+j] = np.conjugate(C.T[l][j])

    H_pbc_t = np.zeros((2*Fn, 2*Fn), dtype='complex')
    B = t/2 * sz
    for j in [0,1]:
        for l in [0,1]:
            H_pbc_t[2*(Fn-1)+l][j] = B[l][j]*np.exp(1j*k)
            H_pbc_t[l][2*(Fn-1)+j] = np.conjugate(B.T[l][j])*np.exp(-1j*k)


    def block_matrix(Fn, k, delta, alpha, x, y, length):

        ''' Return block matrix C corresponding to the sum of H_l at position x, y'''

        C = np.zeros((2, 2), dtype='complex')
        sy = np.array([[0, -1j],[1j, 0]])
        for l in range(1,length):
            d = min(l, length-l)
            d1 = min(Fn*l-(x-y), length*Fn-(Fn*l-(x-y)))
            d2 = min(Fn*l-(y-x), length*Fn-(Fn*l-(y-x)))
            C += - delta/2*1j*sy*(np.exp(1j*k*l)/d1**alpha - np.exp(-1j*k*l)/d2**alpha)

        return C


    H_pbc_delta = np.zeros((2*Fn, 2*Fn), dtype='complex')
    for x in range(Fn):
        for y in range(Fn):
            C = block_matrix(Fn, k, delta, alpha, x, y, length)
            for j in [0,1]:
                for l in [0,1]:
                     H_pbc_delta[2*x+l][2*y+j] = C[l][j]

    H_k = H_local + H_pbc_t + H_pbc_delta

    if rot == True:
        R = rot_sigma_y([0,1,0], np.pi/2, Fn)
        H_k = R@H_k@np.conjugate(R.T)

    return H_k

# Cell

def H_Kitaev_LR_QP_inf(params, k, mu, rot=False, AA=True):

    '''Compute the momentum Hamiltonian with APBC for the Kitaev chain
    with any value of alpha and Fn1/Fn. The system is infinite.'''

    alpha = params['alpha']
    t, delta = params['t'], params['delta']
    Fn1, Fn = params['Fn1'], params['Fn']
    phase, constant = params['phase'], params['constant']

    sx = np.array([[0, 1],[ 1, 0]])
    sy = np.array([[0, -1j],[1j, 0]])
    sz = np.array([[1, 0],[0, -1]])

    H_local = np.zeros((2*Fn, 2*Fn), dtype='complex')
    B = t/2 * sz - delta * 1j * sy
    for x in range(Fn):
        for y in np.arange(x, Fn):
            if x == y:
                if constant == True:
                    A_k = -mu * sz
                else:
                    if AA == False:
                        A_k = -mu * sz * (1-np.cos(2*np.pi*Fn1/Fn*x+phase))
                    else:
                        A_k = -mu * sz * (np.cos(2*np.pi*Fn1/Fn*x+phase))
                for j in [0,1]:
                    for l in [0,1]:
                        H_local[2*x+l][2*y+j] = A_k[l][j]
            elif y == x + 1:
                for j in [0,1]:
                    for l in [0,1]:
                        H_local[2*x+l][2*y+j] = B[l][j]
                        H_local[2*y+l][2*x+j] = np.conjugate(B.T[l][j])
            else:
                d = y-x
                C = - delta/d**alpha * 1j * sy
                for j in [0,1]:
                    for l in [0,1]:
                        H_local[2*x+l][2*y+j] = C[l][j]
                        H_local[2*y+l][2*x+j] = np.conjugate(C.T[l][j])

    H_pbc_t = np.zeros((2*Fn, 2*Fn), dtype='complex')
    B = t/2 * sz
    for j in [0,1]:
        for l in [0,1]:
            H_pbc_t[2*(Fn-1)+l][j] = B[l][j]*np.exp(1j*k)
            H_pbc_t[l][2*(Fn-1)+j] = np.conjugate(B.T[l][j])*np.exp(-1j*k)

    H_pbc_delta = np.zeros((2*Fn, 2*Fn), dtype='complex')
    for x in range(Fn):
        for y in range(Fn):
            C = - delta * 1j * sy * np.exp(1j*k)/Fn**alpha*HLP(k, alpha, Fn, x, y)
            for j in [0,1]:
                for l in [0,1]:
                     H_pbc_delta[2*x+l][2*y+j] = C[l][j]

    H_k = H_local + H_pbc_t + H_pbc_delta + np.conjugate(H_pbc_delta.T)

    if rot == True:
        R = rot_sigma_y([0,1,0], np.pi/2, Fn)
        H_k = R@H_k@np.conjugate(R.T)

    return H_k


def d_k_H_Kitaev_LR_QP_inf(params, k, mu, rot=False, AA=True):

    ''' Analytical derivative of the Hamiltonian for k in momentum space for an infinite system. '''

    alpha = params['alpha']
    t, delta = params['t'], params['delta']
    Fn1, Fn = params['Fn1'], params['Fn']
    phase, constant = params['phase'], params['constant']

    sx = np.array([[0, 1],[ 1, 0]])
    sy = np.array([[0, -1j],[1j, 0]])
    sz = np.array([[1, 0],[0, -1]])

    d_H_pbc_t = np.zeros((2*Fn, 2*Fn), dtype='complex')
    B = t/2 * sz
    for j in [0,1]:
        for l in [0,1]:
            d_H_pbc_t[2*(Fn-1)+l][j] = 1j * B[l][j]*np.exp(1j*k)
            d_H_pbc_t[l][2*(Fn-1)+j] = -1j * np.conjugate(B.T[l][j])*np.exp(-1j*k)

    d_H_pbc_delta = np.zeros((2*Fn, 2*Fn), dtype='complex')
    for x in range(Fn):
        for y in range(Fn):
            C = - delta * 1j * sy * 1j * np.exp(1j*k)/Fn**(alpha+1) * (Fn*HLP(k, alpha-1, Fn, x, y)+(x-y)* HLP(k, alpha, Fn, x, y))
            for j in [0,1]:
                for l in [0,1]:
                     d_H_pbc_delta[2*x+l][2*y+j] = C[l][j]

    d_H_k = d_H_pbc_t + d_H_pbc_delta + np.conjugate(d_H_pbc_delta.T)

    if rot == True:
        R = rot_sigma_y(np.array([0,1,0]), np.pi/2, Fn)
        d_H_k = R@d_H_k@np.conjugate(R.T)

    return d_H_k


def d_phase_H_Kitaev_LR_QP_inf(params, k, mu, rot=False, AA=True):

    ''' Analytical derivative of the Hamiltonian for phi in momentum space for an infinite system. '''

    alpha = params['alpha']
    t, delta = params['t'], params['delta']
    Fn1, Fn = params['Fn1'], params['Fn']
    phase, constant = params['phase'], params['constant']

    sx = np.array([[0, 1],[ 1, 0]])
    sy = np.array([[0, -1j],[1j, 0]])
    sz = np.array([[1, 0],[0, -1]])

    d_H_local = np.zeros((2*Fn, 2*Fn), dtype='complex')
    for x in range(Fn):
        for y in np.arange(x, Fn):
            if x == y:
                if constant == True:
                    A_k = 0
                else:
                    if AA == False:
                        A_k = -mu * sz * (np.sin(2*np.pi*Fn1/Fn*x+phase))
                    else:
                        A_k = mu * sz * (np.sin(2*np.pi*Fn1/Fn*x+phase))
                for j in [0,1]:
                    for l in [0,1]:
                        d_H_local[2*x+l][2*y+j] = A_k[l][j]

    d_H_k = d_H_local

    if rot == True:
        R = rot_sigma_y(np.array([0,1,0]), np.pi/2, Fn)
        d_H_k = R@d_H_k@np.conjugate(R.T)

    return d_H_k

# Cell

def h_chiral_Kitaev_LR_QP(params, k, mu, length, AA=False):

    '''Computes one block of the off-diagonal Hamiltonian in momentum space for a finite system with APBC'''

    alpha = params['alpha']
    t, delta = params['t'], params['delta']
    Fn1, Fn = params['Fn1'], params['Fn']
    phase, constant = params['phase'], params['constant']

    H_local = np.zeros((Fn, Fn), dtype='complex')
    for x in range(Fn):
        for y in np.arange(x, Fn):
            if x == y:
                if constant == True:
                    H_local[x][y] = -mu
                else:
                    if AA == False:
                        H_local[x][y] = -mu * (1-np.cos(2*np.pi*Fn1/Fn*x+phase))
                    else:
                        H_local[x][y] = -mu * (np.cos(2*np.pi*Fn1/Fn*x+phase))
            elif y == x + 1:
                    H_local[x][y] = -delta + t/2
                    H_local[y][x] = + delta + t/2
            else:
                d = min(abs(y-x), length*Fn-abs(y-x))
                H_local[x][y] = -delta/d**alpha
                H_local[y][x] = + delta/d**alpha

    H_pbc_t = np.zeros((Fn, Fn), dtype='complex')
    H_pbc_t[Fn-1][0] = t/2*np.exp(1j*k)
    H_pbc_t[0][Fn-1] = t/2*np.exp(-1j*k)

    H_pbc_delta = np.zeros((Fn, Fn), dtype='complex')
    for x in range(Fn):
        for y in range(Fn):
            c = 0
            for l in range(1,length):
                d1 = min(Fn*l-(x-y), length*Fn-(Fn*l-(x-y)))
                d2 = min(Fn*l-(y-x), length*Fn-(Fn*l-(y-x)))
                c += - delta/2*(np.exp(1j*k*l)/d1**alpha - np.exp(-1j*k*l)/d2**alpha)
            H_pbc_delta[x][y] = c

    Hc = H_local + H_pbc_t + H_pbc_delta

    return Hc

# Cell

def h_chiral_Kitaev_LR_QP_inf(params, k, mu, AA, H_pbc_delta):

    '''Computes one block of the off-diagonal Hamiltonian in momentum space for an infinite system'''

    alpha = params['alpha']
    t, delta = params['t'], params['delta']
    Fn1, Fn = params['Fn1'], params['Fn']
    phase, constant = params['phase'], params['constant']

    H_local = np.zeros((Fn, Fn), dtype='complex')
    for x in range(Fn):
        for y in np.arange(x, Fn):
            if x == y:
                if constant == True:
                    H_local[x][y] = -mu
                else:
                    if AA == False:
                        H_local[x][y] = -mu * (1-np.cos(2*np.pi*Fn1/Fn*x+phase))
                    else:
                        H_local[x][y] = -mu * (np.cos(2*np.pi*Fn1/Fn*x+phase))
            elif y == x + 1:
                    H_local[x][y] = -delta + t/2
                    H_local[y][x] = + delta + t/2
            else:
                d = (y-x)
                H_local[x][y] = -delta/d**alpha
                H_local[y][x] = + delta/d**alpha

    H_pbc_t = np.zeros((Fn, Fn), dtype='complex')
    H_pbc_t[Fn-1][0] = t/2*np.exp(1j*k)
    H_pbc_t[0][Fn-1] = t/2*np.exp(-1j*k)

    Hc = H_local + H_pbc_t + H_pbc_delta - np.conjugate(H_pbc_delta.T)

    return Hc

def H_pbc_sp(params, k):

    '''Computes the analytical expression of the long-range infinite part of
    the off-diagonal Hamiltonian. Does not depend on the chemical potential.'''

    alpha = params['alpha']
    delta = params['delta']
    Fn1, Fn = params['Fn1'], params['Fn']

    H_pbc_delta = np.zeros((Fn, Fn), dtype='complex')
    for dist in np.arange(-(Fn-1), Fn):
        c = - delta * np.exp(1j*k)/Fn**alpha * HLP_d(k, alpha, Fn, dist)
        for x in range(Fn):
            for y in range(Fn):
                if dist == (y-x):
                    H_pbc_delta[x][y] = c

    return H_pbc_delta

def d_h_chiral_Kitaev_LR_QP_inf(params, k, mu, AA, d_H_pbc_delta):

    '''Computes the analytical derivative of k of one block of the off-diagonal Hamiltonian
    in momentum space for an infinite system'''

    alpha = params['alpha']
    t, delta = params['t'], params['delta']
    Fn1, Fn = params['Fn1'], params['Fn']
    phase, constant = params['phase'], params['constant']

    d_H_pbc_t = np.zeros((Fn, Fn), dtype='complex')
    d_H_pbc_t[Fn-1][0] = 1j*t/2*np.exp(1j*k)
    d_H_pbc_t[0][Fn-1] = -1j*t/2*np.exp(-1j*k)

    Hc = d_H_pbc_t + d_H_pbc_delta - np.conjugate(d_H_pbc_delta.T)

    return Hc

def d_H_pbc_sp(params, k):

    '''Computes the analytical derivative of the long-range infinite part of
    the off-diagonal Hamiltonian. Does not depend on the chemical potential.'''

    alpha = params['alpha']
    delta = params['delta']
    Fn1, Fn = params['Fn1'], params['Fn']

    d_H_pbc_delta = np.zeros((Fn, Fn), dtype='complex')
    for dist in np.arange(-(Fn-1), Fn):
        c = - delta * 1j * np.exp(1j*k)/Fn**(alpha+1) * (Fn*HLP_d(k, alpha-1, Fn, dist)- dist * HLP_d(k, alpha, Fn, dist))
        for x in range(Fn):
            for y in range(Fn):
                if dist == (y-x):
                    d_H_pbc_delta[x][y] = c

    return d_H_pbc_delta

def HLP_d(k, alpha, Fn, dist):

    '''Closed form of sum of exponens using HLP function. dist is y-x'''

    f = lerchphi(np.exp(1j*k),alpha,(Fn+(dist))/Fn)
    return np.float(re(f))+ 1j*np.float(im(f))

# Cell

def H_OBC_Kitaev_twoband(params, mu, length, rot=False):

    '''Compute the real space Hamiltonian with APBC for the Kitaev chain
    with any value of alpha and finite length'''

    alpha = params['alpha']
    t, delta = params['t'], params['delta']

    sy = np.array([[0, -1j],[1j, 0]])
    sz = np.array([[0, 1],[ 1, 0]])
    sx = np.array([[1, 0],[0, -1]])

    H = np.zeros((2*length, 2*length), dtype='complex')
    B = t/2 * sz - delta * 1j * sy
    for x in range(length):
        for y in np.arange(x, length):
            if x == y:
                A_k = -mu * sz
                for j in [0,1]:
                    for l in [0,1]:
                        H[2*x+l][2*y+j] = A_k[l][j]
            elif y == x + 1:
                for j in [0,1]:
                    for l in [0,1]:
                        H[2*x+l][2*y+j] = B[l][j]
                        H[2*y+l][2*x+j] = np.conjugate(B.T[l][j])
            else:
                d = y-x
                C = - delta/d**alpha * 1j * sy
                for j in [0,1]:
                    for l in [0,1]:
                        H[2*x+l][2*y+j] = C[l][j]
                        H[2*y+l][2*x+j] = np.conjugate(C.T[l][j])

    if rot == True:
        R = rot_sigma_y([0,1,0], np.pi/2, length)
        H = R@H@np.conjugate(R.T)

    return H

# Cell

def H_APBC_Kitaev_twoband(params, mu, length, rot=False):

    '''Compute the real space Hamiltonian with APBC for the Kitaev chain
    with any value of alpha and finite length'''

    alpha = params['alpha']
    t, delta = params['t'], params['delta']

    sy = np.array([[0, -1j],[1j, 0]])
    sz = np.array([[0, 1],[ 1, 0]])
    sx = np.array([[1, 0],[0, -1]])

    H = np.zeros((2*length, 2*length), dtype='complex')
    B = t/2 * sz - delta * 1j * sy
    for x in range(length):
        for y in np.arange(x, length):
            if x == y:
                A_k = -mu * sz
                for j in [0,1]:
                    for l in [0,1]:
                        H[2*x+l][2*y+j] = A_k[l][j]
            elif y == x + 1:
                for j in [0,1]:
                    for l in [0,1]:
                        H[2*x+l][2*y+j] = B[l][j]
                        H[2*y+l][2*x+j] = np.conjugate(B.T[l][j])
            else:
                d = min(y-x, length-(y-x))
                C = - delta/d**alpha * 1j * sy
                for j in [0,1]:
                    for l in [0,1]:
                        H[2*x+l][2*y+j] = C[l][j]
                        H[2*y+l][2*x+j] = np.conjugate(C.T[l][j])

    B = t/2 * sz
    for j in [0,1]:
        for l in [0,1]:
            H[2*(length-1)+l][j] += -B[l][j]
            H[l][2*(length-1)+j] += np.conjugate(-B.T[l][j])

    if rot == True:
        R = rot_sigma_y([0,1,0], np.pi/2, length)
        H = R@H@np.conjugate(R.T)

    return H

# Cell

def H_Kitaev_twoband(params, k, mu, length, rot=True):

    '''Compute the two band momentum Hamiltonian with APBC for the Kitaev chain
    with any value of alpha and finite length'''

    alpha = params['alpha']
    t, delta = params['t'], params['delta']

    sy = np.array([[0, -1j],[1j, 0]])
    if rot == True:
        sz = np.array([[0, 1],[ 1, 0]])
        sx = np.array([[1, 0],[0, -1]])
    else:
        sx = np.array([[0, 1],[ 1, 0]])
        sz = np.array([[1, 0],[0, -1]])

    H_local = -mu * sz
    H_hop = t * sz * np.cos(k)

    H_l = np.zeros((2,2), dtype='complex')
    for l in range(1,length):
        d = min(l, length-l)
        H_l += -delta/d**alpha*sy*np.sin(k*d)

    H_k = H_local + H_hop + H_l

    return H_k

# Cell

def H_Kitaev_twoband_inf(params, k, mu, rot=True):

    '''Compute the bulk Hamiltonian for the infinite Kitaev chain'''

    alpha = params['alpha']
    t, delta = params['t'], params['delta']*2

    sx = np.array([[0, 1],[ 1, 0]])
    sy = np.array([[0, -1j],[1j, 0]])
    sz = np.array([[1, 0],[0, -1]])

    if rot == False:
        d = np.array([0, -delta*f(k, alpha), t*np.cos(k)-mu])
    else:
        d = np.array([t*np.cos(k)-mu, -delta*f(k, alpha), 0])
    H = d[0]*sx + d[1]*sy + d[2]*sz

    return H


def analytic_Kitaev_twoband(params, k, mu, rot=True):

    '''Compute the analytic form of the evals and evecs for the
    bulk Hamiltonian for the two-band infinite Kitaev chain'''

    alpha = params['alpha']
    t, delta = params['t'], params['delta']

    sx = np.array([[0, 1],[ 1, 0]])
    sy = np.array([[0, -1j],[1j, 0]])
    sz = np.array([[1, 0],[0, -1]])

    if rot == False:
        d = np.array([0, delta*f(k, alpha), t*np.cos(k)-mu])
    else:
        d = np.array([t*np.cos(k)-mu, delta*f(k, alpha), 0])

    evec1 = np.array([d[2]+np.linalg.norm(d), d[0]+1j*d[1]])
    evec2 = np.array([1j*d[1]-d[0], d[2]+np.linalg.norm(d)])
    evecs = np.array([evec1, evec2]).T

    E = np.linalg.norm(d)
    evals = np.array([-E,E])

    return evals, evecs

# Cell

def h_Kitaev_twoband(params, k, mu, length):

    '''Compute one block of the off-diagonal form of two band momentum Hamiltonian
    with APBC for the Kitaev chain. Finite system.'''

    alpha = params['alpha']
    t, delta = params['t'], params['delta']

    f = 0
    for l in range(1,length):
        d = min(l, length-l)
        f += 1/d**alpha*np.sin(k*d)
    h = -mu + t * np.cos(k) - 1j*delta*f

    return h


def d_h_Kitaev_twoband(params, k, mu, length, rotation=True):

    '''Compute the analytical derivative of one block of the off-diagonal form of two band
    momentum Hamiltonian with APBC for the Kitaev chain. Finite system. There is a problem
    with the definition of the derivative.'''

    alpha = params['alpha']
    t, delta = params['t'], params['delta']

    df = 0
    for l in range(1,length):
        d = min(l, length-l)
        l_mod = d
        df += 1/d**alpha*l_mod*np.cos(k*l_mod)
    dh = - t * np.sin(k) - 1j*delta*df

    return dh

# Cell

def h_Kitaev_twoband_inf(params, k, mu, rotation=True):

    '''Compute one block of the off-diagonal form of two band momentum Hamiltonian
    with APBC for the Kitaev chain. Infinite system.'''

    alpha = params['alpha']
    t, delta = params['t'], params['delta']
    h = t*np.cos(k)-mu - 1j*delta*f(k, alpha)

    return h


def d_h_Kitaev_twoband_inf(params, k, mu, rotation=True):

    '''Compute the analytical derivative of one block of the off-diagonal form of two band
    momentum Hamiltonian with APBC for the Kitaev chain. Infinite system.'''

    alpha = params['alpha']
    t, delta = params['t'], params['delta']
    d_h = - t*np.sin(k) - 1j*delta*df(k, alpha)

    return d_h

# Cell

def H_OBC_Kitaev_SR_QP(params, mu, length, rot=False, AA=False):

    '''Compute the real space OBC Hamiltonian for the Kitaev chain
    with any value of alpha and Fn1/Fn and short range'''

    t, delta = params['t'], params['delta']
    Fn1, Fn = params['Fn1'], params['Fn']
    phase, constant = params['phase'], params['constant']
    sx = np.array([[0, 1],[ 1, 0]])
    sy = np.array([[0, -1j],[1j, 0]])
    sz = np.array([[1, 0],[0, -1]])

    H_local = np.zeros((2*Fn*length, 2*Fn*length), dtype='complex')

    B = t/2 * sz + delta/2 * 1j * sy
    for i in range(Fn*length-1):
        if constant == True:
            A_k = mu * sz
        else:
            if AA == False:
                A_k = mu * sz * (1-np.cos(2*np.pi*Fn1/Fn*i+phase))
            else:
                A_k = mu * sz * (np.cos(2*np.pi*Fn1/Fn*i+phase))
        for j in [0,1]:
            for l in [0,1]:
                H_local[2*i+j][2*i+l] = A_k[j][l]
                H_local[2*i+l][2*(i+1)+j] = B[j][l]
                H_local[2*(i+1)+j][2*i+l] = np.conjugate(B.T[l][j])

    i = Fn*length-1
    if constant == True:
        A_k = mu * sz
    else:
        if AA == False:
            A_k = mu * sz * (1-np.cos(2*np.pi*Fn1/Fn*i+phase))
        else:
            A_k = mu * sz * (np.cos(2*np.pi*Fn1/Fn*i+phase))
    for j in [0,1]:
        for l in [0,1]:
            H_local[2*i+j][2*i+l] = A_k[j][l]

    if rot == True:
        R = rot_sigma_y([0,1,0], np.pi/2, length*Fn)
        H_local = R@H_local@np.conjugate(R.T)

    return H_local


def H_OBC_Majoranas_Kitaev_SR_QP(params, mu, length, rot = False, AA = False):

    '''Compute the real space Hamiltonian with OBC for the Kitaev chain
    with any value of alpha, Fn1/Fn and finite length. Here we use the Majorana basis.'''

    mu = mu*2
    alpha = params['alpha']
    t, delta = params['t']*2, params['delta']*4
    Fn1, Fn = params['Fn1'], params['Fn']
    phase, constant = params['phase'], params['constant']

    sx = np.array([[0, 1],[ 1, 0]])
    sy = np.array([[0, -1j],[1j, 0]])
    sz = np.array([[1, 0],[0, -1]])

    H_local = np.zeros((2*Fn*length, 2*Fn*length), dtype='complex')
    B = t/4 * sy - delta/4 * 1j * sx
    for x in range(Fn*length):
        for y in np.arange(x, Fn*length):
            if x == y:
                if constant == True:
                    A_k = -mu/2 * sy
                else:
                    if AA == False:
                        A_k = -mu/2 * sx * 1j * (1-np.cos(2*np.pi*Fn1/Fn*x+phase))
                    else:
                        A_k = -mu/2 * sy * (np.cos(2*np.pi*Fn1/Fn*x+phase))
                for j in [0,1]:
                    for l in [0,1]:
                        H_local[2*x+l][2*y+j] = A_k[l][j]
            elif y == x + 1:
                for j in [0,1]:
                    for l in [0,1]:
                        H_local[2*x+l][2*y+j] = B[l][j]
                        H_local[2*y+l][2*x+j] = np.conjugate(B.T[l][j])

    if rot == True:
        R = rot_sigma_y([0,1,0], np.pi/2, length*Fn)
        H_local = R@H_local@np.conjugate(R.T)

    return H_local


def H_Kitaev_SR_QP(params, k, mu, rot=False, AA=False):

    '''Compute the bulk Hamiltonian (Nambu spinor basis) for the Kitaev chain
    with any value of alpha and Fn1/Fn'''

    t, delta = params['t'], params['delta']
    Fn1, Fn = params['Fn1'], params['Fn']
    phase, constant = params['phase'], params['constant']
    sx = np.array([[0, 1],[ 1, 0]])
    sy = np.array([[0, -1j],[1j, 0]])
    sz = np.array([[1, 0],[0, -1]])

    H_local = np.zeros((2*Fn, 2*Fn), dtype='complex')
    H_pbc = np.zeros((2*Fn, 2*Fn), dtype='complex')

    B = t/2 * sz + delta/2 * 1j * sy
    for i in range(Fn-1):
        if constant == True:
            A_k = mu * sz
        else:
            if AA == False:
                A_k = mu * sz * (1-np.cos(2*np.pi*Fn1/Fn*i+phase))
            else:
                A_k = mu * sz * (np.cos(2*np.pi*Fn1/Fn*i+phase))
        for j in [0,1]:
            for l in [0,1]:
                H_local[2*i+j][2*i+l] = A_k[j][l]
                H_local[2*i+l][2*(i+1)+j] = B[j][l]
                H_local[2*(i+1)+j][2*i+l] = np.conjugate(B.T[l][j])

    i = Fn-1
    if constant == True:
        A_k = mu * sz
    else:
        if AA == False:
            A_k = mu * sz * (1-np.cos(2*np.pi*Fn1/Fn*i+phase))
        else:
            A_k = mu * sz * (np.cos(2*np.pi*Fn1/Fn*i+phase))
    for j in [0,1]:
        for l in [0,1]:
            H_local[2*i+j][2*i+l] = A_k[j][l]

    for j in [0,1]:
        for l in [0,1]:
            H_pbc[2*(Fn-1)+l][j] = B[j][l]

    H_k = H_local + np.exp(1j*k)*H_pbc + np.exp(-1j*k)*H_pbc.T

    if rot == True:
        R = rot_sigma_y([0,1,0], np.pi/2, length)
        H_k = R@H_k@np.conjugate(R.T)

    return H_k

# Cell

def Fibonacci(iterations):

    """Return Fibonacci sequence number depending on the iterations"""

    Fn1 = 0
    Fn = 1
    for n in range(iterations):
        Fn2 = Fn1
        Fn1 = Fn
        Fn = Fn1 + Fn2

    return Fn1, Fn


def rot_sigma_y(pvec, psi, Fn):

    '''Rotation around sigma y of an angle psi'''

    a = np.array([[np.cos(psi/2)-1j*pvec[2]*np.sin(psi/2), (-1j*pvec[0]-pvec[1])*np.sin(psi/2)],
                  [(-1j*pvec[0]+pvec[1])*np.sin(psi/2), np.cos(psi/2)+1j*pvec[2]*np.sin(psi/2)]])
    b = np.identity(Fn)

    return np.kron(b,a)


def f(k, alpha):

    '''Function f(k,alpha) in terms of the polylog functions'''

    f = -1j/2*(polylog(alpha,np.exp(1j*k))-polylog(alpha, np.exp(-1j*k)))
    return float(f.real) + 1j*float(f.imag)


def df(k, alpha):

    '''Derivative of function f(k,alpha) in terms of the polylog functions'''

    f = 1/2*(polylog(alpha-1,np.exp(1j*k))+polylog(alpha-1, np.exp(-1j*k)))
    return float(f.real) + 1j*float(f.imag)


def HLP(k, alpha, Fn, x, y):

    '''Closed form of sum of exponens using HLP function'''

    f = lerchphi(np.exp(1j*k),alpha,(Fn+(y-x))/Fn)
    return np.float(re(f))+ 1j*np.float(im(f))

# Cell

def sparse_diag(matrix, k, sigma=0, **kwargs):

    '''Call sla.eigsh with mumps support.'''

    class LuInv(sla.LinearOperator):
        def __init__(self, A):
            inst = mumps.MUMPSContext()
            inst.analyze(A, ordering='pord')
            inst.factor(A)
            self.solve = inst.solve
            sla.LinearOperator.__init__(self, A.dtype, A.shape)

        def _matvec(self, x):
            return self.solve(x.astype(self.dtype))
    opinv = LuInv(matrix - sigma * identity(matrix.shape[0]))
    return sla.eigsh(matrix, k, sigma=sigma, OPinv=opinv, **kwargs)